# 📘 Terminal IDE 상세 워크플로우 가이드

본 문서는 단순히 "무슨 키를 누르면 무엇이 실행된다"를 넘어, 실제로 Zsh, Tmux, 그리고 **60개의 Neovim 플러그인**을 유기적으로 이어 붙여 개발 속도를 극대화하는 **실전 워크플로우 시나리오**를 안내합니다.

모든 단축키와 플러그인은 상호 충돌이 없도록 신중하게 조정되었으며, 핵심 치트시트 요약은 [`docs/cheatsheet.md`](cheatsheet.md)를 참고하세요.

---

## 시나리오 1: 프로젝트 구동과 터미널 매니징

개발의 시작은 디렉토리 진입 및 환경 설정입니다.

1. **Zsh와 Direnv 조합**:
   특정 폴더로 이동(`cd my-project` 또는 `z my`)하면, 그 순간 `direnv`가 `.envrc`를 읽고 백그라운드 서버 API 키나 Docker 환경 변수 등을 자동 활성화합니다.
2. **Tmux 세션 점프 (`Ctrl+a` 후 `o`)**:
   개발 중 갑자기 다른 프로젝트 참조가 필요하다면, 기존 레이아웃을 부수지 말고 `prefix + o` (SessionX)를 누릅니다. 퍼지 검색을 통해 눈 깜짝할 새 참조할 프로젝트 세션으로 다녀올 수 있습니다.
3. **Lazygit + Floax (`Ctrl+a` 후 `p`)**:
   기능을 하나 끝냈나요? 터미널을 빠져나가 거치광스런 Git 명령어를 치지 마세요. `prefix + p`로 팝업 터미널을 열고 Zsh 단축어 `g`<Space> (또는 Neovim 안에서라면 `<leader>gg`)를 눌러 시각적인 Lazygit을 통해 원버튼 스테이징과 브랜치 푸시를 진행합니다. 완료 후 다시 `prefix + p`로 창을 숨깁니다.

---

## 시나리오 2: 뇌와 코드의 동기화 (AI 코딩)

코딩의 절반은 AI가 담당합니다.

1. **Github Copilot 자동 완성과 제안 수락 (`Ctrl+l`)**:
   주석을 적어두고 줄바꿈을 하면 Copilot이 흐린 회색으로 코드를 예측합니다. 마음에 들면 Normal 모드에서 빠져나갈 필요 없이 Insert 모드 상태 그대로 `Ctrl+l`(`^l`)을 눌러 확정 짓고 넘어갑니다.
2. **복잡한 리팩토링 및 설계 상담 (Avante `<leader>aa`)**:
   단순 자동 완성으로는 해결이 안 되는 버그나 "전체 코드를 리팩토링 해줘" 같은 고차원적인 요청이 필요하다면 `<leader>aa`를 눌러 Avante AI 사이드바를 호출합니다.
   원하는 코드 블록을 드래그한 상태(`Visual` 모드)로 요청을 전송하면, 수정된 코드가 즉석으로 파일 본문에 인라인 병합 대기열(Diff UI)에 뜹니다.
3. **에러 메시지 즉시 AI 디버깅 (`<leader>ad`)**:
   코드를 짜다가 터미널이나 LSP에서 에러/경고 밑줄이 생겼을 때 바로 **`<leader>ad`**를 누르세요. 현재 열려있는 파일의 에러 메시지(Diagnostics)를 자동으로 모두 수집하여 Avante 채팅창으로 넘기고, "이 에러들을 분석하고 픽스해줘"라고 자동 요청합니다. 복사/붙여넣기 할 필요 없이 원클릭 솔루션입니다.

---

## 시나리오 3: 생각하는 속도로 코드 탐색하기

탐색기(File Tree)를 띄워놓고 마우스로 클릭하는 것은 너무 느립니다.

1. **전역 텍스트/파일 검색 (Telescope `<leader>ff` / `<leader>fg`)**:
   LSP가 연결되어 있지 않은 텍스트조차도 프로젝트의 끝에서 끝까지 단숨에 찾아냅니다. 퍼지 검색이므로 `crtl` `sve` 처럼 대충 오타가 난 경로를 입력해도 오차 범위를 좁혀줍니다.
2. **초고속 즐겨찾기 (Harpoon `<leader>ha` / `<leader>h1~4`)**:
   Model, View, Controller 파일 3개를 쉴 틈 없이 번갈아가며 수정해야 하나요? 각 파일에서 `<leader>ha`를 눌러 1~3번 인덱스로 등록합니다. 이후 어떤 열린 탭이나 화면 안쪽이든 상관없이 `<leader>h1`, `<leader>h2`를 누르는 것만으로 파일이 즉시 스위칭 됩니다.
3. **화면 텍스트 스나이핑 (Flash `s`)**:
   현재 화면에 띄워져 있는 저 함수 괄호 속으로 이동하고 싶다면? 조준 모드 단축키 `s`를 누른 뒤 대상 문자의 앞 두 글자만 치면 모든 화면 요소가 알파벳 레이블로 스캐닝 캡처 처리됩니다. 레이블 키를 누르면 0.1초 만에 텔레포트합니다.

---

## 시나리오 4: 의미론적 텍스트 편집 (Semantic Editing)

Neovim 내 편집 기능은 LSP 엔진과 SQLite 텍스트 엔진과 결합되어 있습니다.

1. **Inc-Rename (`<leader>cr`)**:
   변수 위에 커서를 올리고 명령을 누릅니다. 하단 입력창에서 단어를 지우고 수정하는 모든 기록이 파일 전역에 걸쳐 **미리보기(Live Preview)** 형태로 나타납니다. 오타나 적용 범위를 눈으로 100% 확신한 뒤 확정 짓습니다.
2. **안전한 클립보드 재활용 (Neoclip `<leader>fy` & Visual `p`)**:
   방금 10줄짜리 함수를 복사(`y`)했습니다. 그런데 다른 줄을 지우느라(`d`) 클립보드가 방금 지운 "한 글자"로 덮어씌워져 버렸습니다. 낙담하지 마세요. `<leader>fy`를 누르거나, 지울 영역을 Visual 블록으로 잡고 그대로 **Visual `p`** (붙여넣기)를 시전하면 기본 시스템은 덮어쓰고 클립보드 원본은 안전하게 보존합니다.
3. **다중 커서 동시 편집 (Multicursor `<Ctrl-n>`)**:
   해당 변수를 한 세 번만 밑으로 넘어가며 수정할 필요가 있다면, 변수에 커서를 두고 `<Ctrl-n>`을 누릅니다. 선택된 텍스트가 아래로 뻗어 내려가며 여러 줄을 한 번에 편집하게 해줍니다.
4. **⚠️ Dial.nvim 스마트 증감 연산자 통합 예외 사항**:
   불리언(`true`)을 증가(`Ctrl+a`)시키면 `false`가 되도록 하는 똑똑한 매핑이 있습니다. 하지만 **현재 Tmux Prefix가 `Ctrl+a`** 이기 때문에 터미널이 최초로 이 입력을 가로채갑니다. Neovim 안에서 "코드 수치화 증가 연산"으로 쓰고 싶을 경우 **`Ctrl+a`를 두 번 타건 (`Ctrl+a` ➔ `Ctrl+a`)** 해야 합니다. Tmux의 `send-prefix`를 통해 Neovim으로 신호가 투과 전달되기 때문입니다.

---

## 시나리오 5: 단축키가 기억나지 않을 때 대처법

- **Neovim 안일 경우 `<Space> s k` 또는 `<Space> ?`**
  등록된 수천 개의 키맵이 주석 설명과 함께 모두 출력되며 퍼지 검색할 수 있습니다. 가장 필수적인 코어 기능들은 중앙에 렌더링되는 팝업 치트시트(`Spc ?`) 명령어로 볼 수 있습니다.
- **오동작 혹은 Zsh 로그 확인이 필요할 때**
  터미널 위에서 Tmux 스크래핑 기능인 `prefix + Tab` (Extrakto)를 켜면 마우스 없이도 화면 텍스트 전체를 구조화해서 클립보드에 담을 수 있게 됩니다.
